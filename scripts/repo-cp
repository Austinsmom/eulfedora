#!/usr/bin/env python

# file scripts/repo-cp
#
#   Copyright 2015 Emory University Libraries & IT Services
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import argparse
import base64
import binascii
from copy import copy
from cStringIO import StringIO
import ConfigParser
import hashlib
from lxml import etree
import math
import os
import re

from eulxml.xmlmap import load_xmlobject_from_string
from eulfedora.server import Repository
from eulfedora.models import DigitalObject
from eulfedora.util import ChecksumMismatch, PermissionDenied, \
    RequestFailed
from eulfedora.xml import FoxmlDigitalObject
from eulfedora.syncutil import estimate_object_size, ArchiveExport, \
    humanize_file_size

try:
    from progressbar import ProgressBar, Bar, Counter, ETA, \
        FileTransferSpeed, Percentage, \
        RotatingMarker, SimpleProgress, Timer
except ImportError:
    ProgressBar = None



def repo_copy():

    parser = argparse.ArgumentParser()

    # config file options
    cfg_args = parser.add_argument_group('Config file options')
    cfg_args.add_argument('--config', '-c',
        default='$HOME/.repocpcfg',
        help='Load the specified config file (default: %(default)s')

    cfg_args.add_argument('source',
        help='Source repository for content to be copied')
    cfg_args.add_argument('dest',
        help='Destination repository for content to be copied')

    # list of pids
    parser.add_argument('pids', metavar='PID', nargs='*',
        help='list of pids to copy')
    parser.add_argument('--file', '-f',
        help='Input file with a list of pids, one pid per line',
        required=False)
    parser.add_argument('--progress', '-p',
        help='Show progress', action='store_true', default=False)
    parser.add_argument('--export-format', '-e',
        choices=['migrate', 'archive'], default='migrate',
        help='Fedora export format to use.  Use archive if migrate exports ' \
           + 'fail with checksum errors or if content URLs are not accessible '
           + 'to the destination server (default: %(default)s')

    args = parser.parse_args()

    cfg = ConfigParser.ConfigParser()
    configfile_path = args.config.replace('$HOME', os.environ['HOME'])
    with open(configfile_path) as cfgfile:
            cfg.readfp(cfgfile)

    if not cfg.has_section(args.source):
        print 'Source repository %s is not configured' % args.source
        return
    if not cfg.has_section(args.dest):
        print 'Destination repository %s is not configured' % args.dest
        return

    src_repo = Repository(cfg.get(args.source, 'fedora_root'),
        cfg.get(args.source, 'fedora_user'),
        cfg.get(args.source, 'fedora_password'))

    dest_repo = Repository(cfg.get(args.dest, 'fedora_root'),
        cfg.get(args.dest, 'fedora_user'),
        cfg.get(args.dest, 'fedora_password'))

    if args.progress and ProgressBar:
        widgets = ['Transferred: ', FileSizeCounter(), ' ', FileTransferSpeed(), ' ',
                   Timer(format='%s')] # time only, no label like "elapsed time: 00:00"
    else:
        pbar = None

    pids = []
    if args.pids:
        pids = args.pids
    elif args.file:
        with open(args.file) as pidlistfile:
            pids = pidlistfile.read().splitlines()
    else:
        print 'Specify either one or more pids or a file with a list of pids'
        parser.print_help()
        return

    for pid in pids:
        try:
            src_obj = src_repo.get_object(pid)

            # size estimate / progress bar only relevant to archive exports
            if args.export_format == 'archive':
                # calculate rough estimate of object size
                size_estimate = estimate_object_size(src_obj, archive=True)


                if args.progress and ProgressBar:
                    # create a new progress bar with current pid and size
                    current_widgets = [pid,
                        ' Estimated size: %s || ' % humanize_file_size(size_estimate)]
                    current_widgets += widgets
                    pbar = ProgressBar(widgets=current_widgets, maxval=size_estimate)

                # generator to read src repo request in chunks and stream
                # to dest repo
                export = ArchiveExport(src_obj, dest_repo,
                    progress_bar=pbar)
                export_data = export.object_data

            else:
                response = src_repo.api.export(pid, context=args.export_format, stream=True)

                # generator to read src repo request in chunks and stream
                # to dest repo
                def export_data():
                    size = 0
                    for chunk in response.iter_content(4096*1024):
                        size += len(chunk)
                        # update progressbar if we have one & export format is archive
                        if pbar and args.export_format == 'archive':
                            # progressbar doesn't like it when size exceeds maxval,
                            # but we don't actually know maxval; adjust the maxval up
                            # when necessary
                            if pbar.maxval < size:
                                pbar.maxval = size
                            pbar.update(size)
                        yield chunk

        except RequestFailed as err:
            err_type = 'Error'
            if isinstance(err, PermissionDenied):
                err_type = 'Permission denied'
            err_msg = unicode(err)
            if '404' in err_msg:
                err_msg = 'object not found'
            print '%s exporting %s from %s: %s' % \
                (err_type, pid, args.source, err_msg)

            continue

        dest_obj = dest_repo.get_object(pid)
        if dest_obj.exists:
            if cfg.has_option(args.dest, 'allow_overwrite') and \
              cfg.getboolean(args.dest, 'allow_overwrite'):

                print '%s already exists in %s, purging' % (pid, args.dest)
                try:
                    dest_repo.purge_object(pid)
                except RequestFailed as err:
                    err_type = 'Error'
                    if isinstance(err, PermissionDenied):
                        err_type = 'Permission denied'
                    print '%s purging %s from %s: %s' % \
                        (err_type, pid, args.dest, err)
                    # if object exists and purge fails, go to next pid
                    continue
            else:
                print '%s already exists in %s but overwrite is not allowed; skipping'\
                    % (pid, args.dest)
                continue

        try:
            if pbar:
                pbar.start()

            result = dest_repo.ingest(export_data())
            if pbar:
                pbar.finish()
            print '%s copied' % result
        except ChecksumMismatch:
            print 'ChecksumMismatch on %s' % pid

        except RequestFailed as err:
            err_type = 'Error'
            if isinstance(err, PermissionDenied):
                err_type = 'Permission denied'
            print '%s importing %s to %s: %s' % \
                (err_type, pid, args.dest, err)

            continue


class FileSizeCounter(Counter):
    # file size counter widget for progressbar

    def update(self, pbar):
        return humanize_file_size(pbar.currval)



if __name__ == '__main__':
    repo_copy()